---
title: "322. 零钱兑换"
date: 2019-10-10T17:02:43+08:00
description: ""
draft: false
tags: ["array","Backtracking"]
categories: ["Leetcode"]
---



## 题目信息

> - 链接：[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)
> - 来源：LeetCode
> - 难度：中等

### 一、描述

> 只有题目理解到位，你可能进入下面一个环节，如果不熟悉场景，你可要小心了

- 我目的是训练动手和清晰思路。
- 从简单类型的题目开始。
- 提问是沟通的开始：敢于提问


You are given coins of different denominations and a total amount of money amount. 

Write a function to compute the fewest number of coins that you need to make up that amount. 

If that amount of money cannot be made up by any combination of the coins, return -1.

给定不同面额的硬币 coins 和一个总金额 amount。

编写一个函数来计算可以凑成总金额所需的最少的硬币个数。

如果没有任何一种硬币组合能组成总金额，返回 -1。



**说明**:

   你可以认为每种硬币的数量是无限的。






### 二、举例

> 在思路之前和实现之后都用到,基本情况，最好情况，和最坏情况3种。

~~~c++
Example 1:

Input: coins = [1, 2, 5], amount = 11
Output: 3 

Explanation: 11 = 5 + 5 + 1

Example 2: [186,419,83,408] 6249 
    
    
Example 3:
Input: coins = [1], amount = 99999999999 (n很大)

Example 4 :
Input: coins = [336,288,378,16,319,146], amount = 9212 (n很大)

~~~



### 三、解题思路

> 提示：宁愿做不出来题目，在哪里浪费时间，也按照正确刷题姿势，请按照下面准备

- 关闭一切浏览器网页查看分析

- 关闭一切当前处理任务

- 关闭一切要学习的任务。

- 放下：太简单和太难这样预判。真实判断是什么 这是 关键
- 说出思路才能决定能否沟通下去。

  

  

#### 第一次分析：  





看到，[1, 2, 5], amount = 11 ，我第一想到就是就是
$$
case1--11 =2*5+0*2+1 *1 \n   
  case2--11 =1*5+3*2+8*1 \n
 
$$
肉眼观察一下根本观察不出来



暴力解法，给定金额11元，

**有多少个可能组成。选择最小的硬币那个**。**根本不需要考虑其他技巧**。

eg：

每个硬币 5 最多 选择2个，2最多选择5个，1最多选择11个。

需要3层循环就计算出来了。【这就是加法运算】

小白提问：

eg1 通过case1 得到计算结果，其他eg呢，[5,3]   11 假如用2个五组合后，剩余1根本无法3组成。

因此存在肯定失败情况。



遇到的问：有多少个数组，需要循环多次次，数组大小n不确定，无法直接写死多少个循环。【什么时候用递归，什么时候循环】

  backtrackin



类比：

~~~c
          11 
       /   |    \  
      10   9       6
                /  |  \
                5  4   1       
             
~~~





**算法步骤**

- Complexity Analysis
$$
Time complexity：O(S^n) ,  

Space complexity：O(n)
$$


### 四、实现

> 你可以实现。你可以做到

- 你按照你理解，就用最笨方法，你要写出来。其他高级技巧，我不懂，我也会。

- 不要因为不是最佳，最巧妙，最完美。不符合别人网上流程标准解法 就停止写

  通过写，来验证你步骤描述是否正确，你分析是否正确，必须去。

- 在没有写出来之前，拒绝一切总结，写文档，还有告诉别人。

  自己做不到，不清楚事情，你告诉别人，鬼才信呢！

  - 关闭浏览器
  

### 4.1 c++



#### 第一次实现 超时

 测试

[186,419,83,408] 6249 



空间复杂度：O(n)，

在最坏的情况下，递归的最大深度是 n。

因此，我们需要系统递归堆栈使用 O(n) 空间

~~~c++
class Solution {
public:
     int coinChange(vector<int>& coins, int amount)
     {
         vector<int> dp(amount+1,0);
         return coinChange(coins,dp,amount);
     }
    int coinChange(vector<int>& coins,vector<int>& dp, int amount) {
         if(amount < 0)
         {
             return -1;
         }

         if (amount ==0)
         {
             return 0;
         }

         if (dp[amount] >0)
         {
             return dp[amount];
         }
         int number =INT_MAX;

        for( int coin:coins)
        {
           int result =coinChange(coins,dp,amount-coin);

           if(result ==-1)
           {
               continue;
           }
           number =min(number,result+1);
        }
         number= (number ==INT_MAX?-1:number);
         dp[amount] =number;
        return dp[amount];
    }
};
~~~

 #### 第二次代码

![image.png](https://i.loli.net/2020/01/31/sl65foO8yCH2xVm.png)

~~~c++
class Solution {
public:
     int coinChange(vector<int>& coins, int amount)
     {
         vector<int> dp(amount+1,0);
         return coinChange(coins,dp,amount);
     }
    int coinChange(vector<int>& coins,vector<int>& dp, int amount) {
         if(amount < 0)
         {
             return -1;
         }

         if (amount ==0)
         {
             return 0;
         }
         //if (dp[amount] >0)
         if (dp[amount] !=0)
         {
             return dp[amount];//减少递归次数
         }
         int number =INT_MAX;

        for( int coin:coins)
        { 

           if(amount-coin <0)
           {
              continue;
           } 
           int result =coinChange(coins,dp,amount-coin);

           if(result ==-1)
           {
               continue;
           }
           number =min(number,result+1);
        }
         number= (number ==INT_MAX?-1:number);
         dp[amount] =number;
        return dp[amount];
    }
};
~~~



 O(2^n)



371725201209192076

### 第三次次尝试些代码 【超时】

[3,7,405,436]   8839



~~~c++
public class Solution {

  public int coinChange(int[] coins, int amount) {
    return coinChange(0, coins, amount);
  }

  private int coinChange(int idxCoin, int[] coins, int amount) {
    if (amount == 0)
      return 0;
    if (idxCoin < coins.length && amount > 0) {
      int maxVal = amount/coins[idxCoin];
      int minCost = Integer.MAX_VALUE;
      for (int x = 0; x <= maxVal; x++) {
        if (amount >= x * coins[idxCoin]) {
          int res = coinChange(idxCoin + 1, coins, amount - x * coins[idxCoin]);
          if (res != -1) //如果是-1 ，代表组合不成功，无法计算
            minCost = Math.min(minCost, res + x);
        }
      }
      return (minCost == Integer.MAX_VALUE)? -1: minCost;
    }
    return -1;
  }
}

// Time Limit Exceeded


class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        
        //硬币的个数不同层次的硬笔组合累加。回溯暴力破解
        return coinChange(0,coins,amount);
    }

    int coinChange(int index,vector<int>&coins,int amount){

        if (amount ==0)
        {
            return 0; //可以有该金币组成，不需要其他的金币
        }
        
        if (index >= coins.size() || amount <0)
        {
           return -1;// [10] 2 这样是无法组合的。 index <是合法的。
        }

        int maxCount =amount/coins[index];
       
        //类比tree的第i层，每层maxCount个分支
        int levelCount =INT_MAX;
        for(int i=0;i <= maxCount;i++)
        {     
           
             // amount =amount-i*coins[index];
              int temp=amount-i*coins[index];
              int count=coinChange(index+1,coins,temp);
              cout<< "count" <<count << ":"<<temp<<endl;
              if (count == -1)
              {   
                  // cout<<amount <<" ===-1"<<count;
                  continue;
              }
            
              levelCount =min(levelCount,count+i);
              
              cout<<levelCount <<" ";
        }

        return levelCount ==INT_MAX?-1:levelCount;
    }
};

~~~





### 4.2 golang

 #### 4.2.1 Solution1


~~~
/**
执行用时 :
8 ms, 在所有 Go 提交中击败了97.33%的用户
内存消耗 :2.1 MB, 在所有 Go 提交中击败了100.00%的用户
**/
func coinChange(coins []int, amount int) int {
	var lessTotal int = 99999
	sort.Sort(sort.Reverse(sort.IntSlice(coins))) //大到到下
	fmt.Println(coins)

	coinChange2(0, coins, amount, 0, &lessTotal)
	if lessTotal == 99999 {
		lessTotal = -1 //零钱无法找零
	}
	return lessTotal

}

func coinChange2(index int, coins []int, amount int, sum int, lessTotal *int) {

	//走到最低了
	if amount == 0 {
		if sum < *lessTotal {
			*lessTotal = sum

		}
	}

	if amount < 0 {
		return //该组合无法成立
	}

	if index >= len(coins) {
		return //amount 组合不成立
	}

	count := amount / coins[index] //最多多少个该金币组成
	//从最大开始尝试,最少i是0， amount-i*coins[index]数值保持不变
	//如果当前组合超过最小值，后面的递归就不需要判断
	for i := count; i >= 0 && sum+i < *lessTotal; i-- {
		coinChange2(index+1, coins, amount-i*coins[index], sum+i, lessTotal)

	}
}

~~~




### 五、回顾

- 耗时统计 

| 步骤         | 分钟 | 备注             |
| ------------ | ---- | ---------------- |
| 打开题目     | 30   | 都看什么了       |
| 分析题目     | 120  | 我期望没有实现呢 |
| **实现题目** |      |                  |
| **查看答案** |      |                  |

开始：2020年1月31日12:16:05

结束：2020年2月11日07:29:03



**动态规划遵循一套固定的流程：递归的暴力解法 -> 带备忘录的递归解法 -> 非递归的动态规划解法**

数学公式 如何while实现。递归实现



### 六、  举一反三

> 线索地图：换个马甲就不认识了。

- 47.全排列 II
 https://leetcode-cn.com/submissions/detail/34715733/
- [39] 组合总和
- 求二叉树的高度
- 199. 二叉树的右视图
 https://leetcode-cn.com/problems/binary-tree-right-side-view/
> 分享最实用的经验 ， 希望每一位来访的朋友都能有所收获！ 
>

### 七、参考

- 199. 二叉树的右视图
https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/liang-chong-jie-ti-fang-fa-di-gui-ji-bai-100he-fei/

- https://leetcode-cn.com/problems/coin-change/submissions/

- https://leetcode.com/problems/coin-change/solution/

- https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/

- https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-suan-fa-si-xiang-by-hikes/

- https://zxi.mytechroad.com/blog/dynamic-programming/leetcode-322-coin-change/

  https://www.youtube.com/watch?v=uUETHdijzkA

![image-20200131172053710](../images/201909/image-20200131172053710.png)