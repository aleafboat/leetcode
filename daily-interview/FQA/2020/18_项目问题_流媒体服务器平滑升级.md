c

这就是你价值，用不一向的角度回答老问题。

> 别人回答了，那是入门时候，随笔写博客时候，应付项目时候。
>
> 别人迭代了，别人不会重写一本书，一个项目，一个博客纠正。
>
> 别人没有义务纠正你错误。
>
>  你对你认知负责，你需要对你理解负责





## 一、问题



- Nginx平滑升级
- SRS 平滑升级
- nginx 平滑升级
- Tidb升级







## 二、你的思考（10秒闪过

> 范围 代码，官方文档 和项目问题 指出内容







热备 考虑单点故障



集群是不怕单点故障的。










## 三、你的回答（限制在1分钟，5句话，12秒一句）











## 四、鸡蛋里挑骨头（第一句话回答关键了吗，后面有具体场景吗？或者关键词补充吗）

> 如果简单用法，100%保证不过关，因为没有骨头可挑！
>
> 如果自己强加各种特自己根本不理解很深入原理，你保证100个人 80人也说不出来
>
> 从哪里入手呢？
>
> 1 假如100个人去问，大家都问什么相同的题目。
>
> 2 别看不起官方文档，上面最全面。最正确，包含各种情况（大家关系问题在官方文档有答案）【文档每一行都要看，想当然不行的】
>
> 3 自己手动写小demo







## 五、你自己满意了吗,认为过关了

1. 10秒内单，如果大脑一片空白，对里面里面基础用法（不行）

2. 进一步 提问，原理，异常等毫无总结，（不行）

3. 你必须停下来深入看看看别人怎么做的（学习吧）





## 六、下一个问题是什么（这不是结束，只是一个系统的开始）



## 七、如果自己没有做过类型项目，参考别人经验，自己重新设计，需要考虑知识点是什么？











### 八、如果自己没有做过类型项目，参考别人经验，自己直接写demo，和真是项目最大差距是什么？



[腾讯会议用户暴涨，Redis 集群如何实现无缝扩容？](https://mp.weixin.qq.com/s/nKCw_a5mU9sn7SPKmCn-OQ)

1. 无损扩容挑战--大 Key 问题

> 一个 list 也是一个 Key，一个哈希表也是 Key，一个 list 会有上千万的数据，一个哈希表也会有很多的数据
>
> 一般 Redis 业务设置超时大部分是 200 毫秒，有的是 100 毫秒。
>
> 如果同步搬移 Key 超过一秒，就会有大量的超时出现，客户业务就会慢。





DTS直接利用sync命令 ，全量同步，然后增量同步

腾讯采取是带slot sync，也是fork  全量slot ，然后增量slot 



我晕 一个带slot sync  一个直接sync区别。其实过程还是一样的。

文章说到2 倍的资源。DTS是原生命令，mysql dump时候不可能fork，只有redis才有。

都是利用redis特性。







**slot产生过程中产生新数据怎么同步？**

**A：**类似aof概念的机制同步到目标进程。这个aof跟普通aof传输到slave有区别，只会将跟目标slot相关的数据同步过去，而不会同步别的。



sync命令 

![image-20200725104201362](../images/image-20200725104201362.png)





![image-20200725105412048](../images/image-20200725105412048.png)

- replicaof <masterip> <masterport>  
- 用管道代替socket aof_pipe_write_data_to_child
- [aofChildWriteDiffData](http://mysql.taobao.org/monthly/2018/12/06/)

~~~c
 while (1)
    {
        ln = listFirst(server.aof_rewrite_buf_blocks);
        block = ln ? ln->value : NULL;
        if (server.aof_stop_sending_diff || !block)
        {
            aeDeleteFileEvent(server.el, server.aof_pipe_write_data_to_child,
                              AE_WRITABLE);
            return;
        }
        if (block->used > 0)
        {
            nwritten = write(server.aof_pipe_write_data_to_child,
                             block->buf, block->used);
            if (nwritten <= 0)
                return;
            memmove(block->buf, block->buf + nwritten, block->used - nwritten);
            block->used -= nwritten;
            block->free += nwritten;
        }
        if (block->used == 0)
            listDelNode(server.aof_rewrite_buf_blocks, ln);
    }
~~~

http://mysql.taobao.org/monthly/2018/12/06/

https://developpaper.com/aof-rewriting-for-redis-persistence/