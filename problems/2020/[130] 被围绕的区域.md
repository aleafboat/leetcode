```
王阳明

志不立，天下无可成之事。虽百工技艺，未有不本于志者。今学者旷废隳惰，玩岁愒时，而百无所成，皆由于志之未立耳。故立志而圣，则圣矣；立志而贤，则贤矣；志不立，如无舵之舟，无衔之马，漂荡奔逸，终亦何所底乎？

志向不能立定，天下便没有可做得成功的事情。
虽然各种工匠有技能才艺的人，没有不以立志为根本的。

现在的读书人，旷废学业，堕落懒散，贪玩而荒费时日，因此百事无成，这都是由于志向未能立定罢了。

所以立志做圣人，就可以成为圣人了；

立志做贤人，就可成为贤人了。

志向没有立定，就好象没有舵木的船，没有衔环的马，随水漂流，任意奔逃，最后又到什幺地方为止呢？ 
```



###  一、题目描述

> 完成比完美更重要，自己动手写一些看

~~~
 [130] 被围绕的区域

 给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。

 找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
~~~

 [130] 被围绕的区域

 给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。

 找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。



思考 60秒 。。。



思考 60秒 。。





- 放轻松，虽然是c++实现，拒绝奇技淫巧，通俗易懂。
- golang 





### 二、测试用例

> 检查 题目是否看明白，理解有没有偏差





 这个题目试着这里开始入手

算法五个重要的特征：

- 输入项，输出项（题目已经给了）

- 可行性（复杂问题转化成熟悉子问题）

- 有穷性（在算法描述体现）

- 确切性（在算法描述体现）



### 三、解题思路


> 检查 思路是否清晰合理，不是靠道听途说, 别人说这样好就好，

#### 最迷惑地方

1. 按照标准dfs遍历，通过 0,扩展四周 ，如果 x 返回false 如果 0 0 这形成相互依赖，程序死循环了，无法判断是否围绕了。

2. 可能有一个做法能解决这个问题，但是我现在根本想不起来。我从周围连通性判断


#### 熟悉的子问题

1. 给我一个二维数组，我只会i, j 从 0开始遍历

2. 从边界开始向内部扩散的



#### 步骤描述

- 字母 `X`；
- 被字母 `X` 包围的字母 `O`；
- 没有被字母 `X` 包围的字母 `O`



1. 第一次 遍历二维数组，对周边元素 采取 dfs 标记第三个情况 为#，

2. 第二次遍历维数组，#还原0，

    被字母 `X` 包围的字母 `O` 标记 x

   

####  复杂度分析





###  四 、 举一反三



[【每日一题】：LeetCode 329. Longest Increasing Path in a Matrix #5](https://github.com/wangcy6/leetcode/issues/5)



> 分享最实用的经验 ， 希望每一位来访的朋友都能有所收获！
https://github.com/wangcy6/leetcode
> 如果有疑问请联系我，一起探讨，进步。