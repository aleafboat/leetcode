## 题目

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，

判定 s 是否可以被空格拆分为一个**或多个**在字典中出现的单词。

难度：中等

分类：

累计使用：3

## 思路 1  递归和回溯

- 版本1 根据题目意思直接实现（错误的示范）

  遍历字符串，假如当前位置是i，拆分成[0,i],[i,end] 这2个字符，判断这2个字符是否存在词典中。

  如果在字典中 返回ture

  如果不在字典中返回flase

输入: s = "leet|code", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

画外音：

**这是我目前想到的，我的理解，不管别人方法多么巧妙。**

**请马上把思路写出来 不管对错，3分钟就验证结果。**



~~~c
测试结果：
输入:
"applepenapple"
["apple","pen"]
输出
false
预期结果
true

~~~



很明显，这只拆分来了一次penapple，还可以继续拆分。



- 版本2 

  ```
   satrt=0 遍历字符串,
   
   假如当前位置是start=i，拆分成A[0,i],B[i,end] 这2个子串，
   判断这2个字符是否存在词典中。
   如果都AB 在字典中 返回ture
   
   如果A存在，第二个字符不在字典中返回flase，需要对子串B重复上面步骤。
   
   假如A存在，为什么不继续递归A呢，
   因为A 是从0开始累计的，从小到大，顺序判断的。
   假如B不存在，这符合从大到小，start=i,重现判断。
   
  如果在字典中出现过，那么去掉这个前缀后剩余部分回归调用。同时，如果某次函数调用中发现整个字符串都已经被拆分且在字典中出现过了，函数就返回 true
  
  ```

  





复杂度分析 

- 时间复杂度：O(n^n)
   ) 

  考虑最坏情况 s*s* = \text{aaaaaaa}aaaaaaa 。每一个前缀都在字典中，此时回溯树的复杂度会达到 *n**n*

- 空间复杂度：O(n)



[no|]//从小大大过来的，

 [same|smae]

[same|no]//从大到小。

画外音：

**这是我目前想到的，我的理解，不管别人方法多么巧妙。**

**请马上把思路写出来 不管对错，3分钟就验证结果。**